we need to create a python tool to manage our META PROCESS which defines our agentic development cycle, currently we
  put instruction docs in docs/dev to spell out the guidelines, and an agent employ meta process to creat docs/procs
  which create self hydrating docs like QUICKREF TASKS DONE etc, the ai agents have to manually update this and it
  gets messy. we arent quite ready for a db-driven task system, maybe just a file-base one with a TSV or CSV. so i
  createdf this task-py project to help us on that front, basically we want to follow a typical agile process with
  vanity epic namespaces for certain tasks types, either relating to the project or context specific like BUGS-NN,
  DOCS-NN, REF-NN (refactor), RX-NN (research) with story point breakdowns and possible subtasks, think like a
  text-based JIRA but simpler. the agent should be able to use the taskpy tool to determine next priorities change
  status of tickets, create and move tickes (to done or backlog), and link reference docs and code to tickets; as a
  reference most of our rust projects and some of our projects use docs/procs to a varying degree and manually update
  all their docs including a HANDOFF.md; i think a tool would power this better. i think the tool should have a taskpy
  init command to stub out a data folder relative to the project root ./data/kanban and in a typical light weight
  kanban move tasks across different states (and back as needed) add notes and feedback etc, and init should also add
  the kanban to gitignore (create it if its missing); I feel like each task should have its own md file so that
  sufficient detail can be provided as needed. we could do taskpy promote <TASK>-<NN> or something like that to
  migrate through the kanban buckets -- we can have data/kanban/info for meta information like creating a doc that
  lists the allowed EPIC names and allow users to register new ones, so when tasks are created they use one of the
  defined ones; and buckets are just data/kanban/status/<status_dir> so actual tickets get moved literaly through
  taskpy and a manifest gets updated. taskpy can query the manifest to get a list of tasks either all or through some
  filter -- for reference you can find repos/docs/brain i think has a canonical copy of meta process should be there
  and a sample procs/procs.sample that shows how a repo used this meta process - it gets a little sloppy as agents
  start creating files all over the place, i think a better approach is to use  our standard docs/plan directory to
  create strategic detail documents with a PLAN-NN prefix and ot be able to link them to relevant tasks as a
  reference, we also have NFR's that we should keep a manifest of, including a default set; so they can be appended to
  tasks for verification -- and maybe a taskpy verify command that checks that the tests for the particular work done
  are green -- for example at one stage in the lifecycle the developer/agent can add the tests needed for the
  particular ticket via a lifecycle command -- taskpy can call the runner to verify whatever test is needed. we also
  have a testpy and featpy tools that help validate test structure and module structure (module spec v4) and they
  could play together nicely. you can refer to the adjacent python projects to see what theyre using. and we primarily
  want to use this right now with our rust projects but this could branch out to our node and pythong projects so we
  should leave room for extensibility.

 as a backlog item id encourage you to see how our other pytho tools are using our installed boxy and rolo, boxy
provides a decorative casin, and rolo provides structured data formatting, we typically support a --view=data flag
to provide a no frills output, but these tools can help create meaningful "views" for the stakeholders, we want to
provide ergonomic UX for non-agentic users, and tabular data, and task cards, etc are just some possibilities.





all state data for taspy should be in data/kanban you can use that folder however you need to. including a history
 log and active file cursor etc. 1. yes this is more like an opt in system, you dont have to use it it just helps
keep the agent on task. maybe we can have a taskpy strict mode that creates a config entry or marker that requires
the go-flow, session sprint is a little different as thats just saying what to work on overall, what set of tasks do
 we want to target, the go-flow is what am i doing exactly next. 2. tasks shouldnt begin if there are uncommitted
changes, and generally we should snapshot commit anything that is hanging around just so we have a proper record of
the changes. snapshots to branches sounds extra -- but if the auto commit thing is a problem i can just run taskpy
rem to see what was being done. this stuff is really extra and needs its own milestone -- probably needs more
grooming lol -- so yeah its own mileston-4 or whatever, yeah this is sort of tied to a postential taskpy handoff
command maybe handoff create and handoff read, dunno yet. It is useful but its complex, and i want to get the mvp
first before we start adding sparkles




> another backlog item -- for the verify command, maybe even init you need to say what type of project it is, node,
rust, python, shell; we only mostly doing rust and python but soon nodejs

ok next we should discuss promotion gating, i think demote only needs gating if its already in done state, like
specificying a reason, then adding that to the ticket, or even marking it as a regression. for promotion from
backlog/new we just need like a grooming/design/stakeholder review if the requirements arent clear, that should be a
 success criteria for backlog/new/stub tasks by default. that would be enough to get it into dev, promoting from dev
 to.. testing? ready? what did you have for post development? that needs the success criteria of proper test and
code references, and the verify test has to pass. or else it cant be promoted. for promoting out to done, we need a
commit hash to close it out. which we really only want one commit hash per ticket so that works -- waht do you
think?

> yes and there have been times when we had to skip between milestones lol or go back and forth, so making more than
 one active should be allowed. we can also force a milestone into blocked status, which ive had to do manually
sometimes, oh tasks should have blocked status too -- with a reason field eh? like it can other work, or some other
condition, or indefinite -- looking ok so far, the only thing  we'd now is a way to shuttle tasks between miletsones
 as neeeeeeeeeded


> yeah stub is formal for incomplete status. I think new and backlog are mostly the same, unless u see a reason to
differentiate; a backlog item isnt necessarily stub, maybe stub is more like new. ready I think is the pool of tasks
 to bring into the 'session sprint' agents wont have time needs in the same way human teams will. i would say ready
means groomed right? then those are chosen for what to work on next e.g. "session" sprint. you can hav "QA" for the
testing phase, thats clear and easy. i dont konw what we would generate for a grooming checklist


> we should also have a select field that marks tickets for the current session sprint whenver those are decided.
maybe a taskpy sprint command, and the list command can show whats in the sprint vs whats on the board. also for the
 kanban view, you can pipe rolo into boxy, for a table like view.

> also lets add a ticket to create an auto task id for sorting, AUTO_ID or something, then we can use this to sort
the kanban and list views, in order they were created, by ticker sort, or by status. i think no matter what though
priority and status should be default sort order for clarity


lets add some new api commands to the epics system, basically delete (remove an epic), enable/disable to toggle them off or on; and then
epic types, standard vs project/custom. standard epics can only be disabled (delete will only disable and show a warning. we should also add a
 fallback epic UNK (standard), if an epic gets disabled, any ticket wih that epic that is not already active cannot be promoted out of
backlog. any new epic added, is enabled by default and is marked as a project epic type. (make a feat ticket for this), then create a another
feature ticket to update our project tickets with the breakdown you created.

lets also add to the epic management, fuzzy keywords/tags, if these keywords appear in a ticket title, we can recommend a better ticket;
this should be a general functoin to gather the epic keywords/tags in the epics.toml, and find the mapping. this can show as a recommendation
on the create command, and especially if using a standard epic where a project specific epic would provide clearer scope, and note that they
can use the type system instead, so if they specificy a BUG-NN ticket, we know that is a bug type, and say hey we foudn this keyword in COOL
epic and since its a bug type just set it to type B; to support this we can track the last active ticket created, and offer a repair command
to enact the recommended changes to automatically update the ticket and update the manifest. wdyt?
